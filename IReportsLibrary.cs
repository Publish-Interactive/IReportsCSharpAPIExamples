//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.2.0.0 (NJsonSchema v9.2.4.0) (http://NSwag.org)
// </auto-generated>
//----------------------

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Newtonsoft.Json;

public partial class IReportsLibrary
    : IDisposable
{
    private HttpClient httpClient;

    public IReportsLibrary(string baseUrl, HttpClient httpClient)
    {
        this.httpClient = httpClient;
        this.httpClient.BaseAddress = new Uri(baseUrl);
    }

    /// <summary>Uploads a file and makes it ready for processing</summary>
    /// <returns>The document uploaded successfully, but not processed. Returns the id to use in future requests.</returns>
    public Task<int> PostImportAsync(string libraryCode, string productCode, ProductImportDataModel body)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/imports";
        return this.Post<int>(url, body, HttpStatusCode.Accepted);
    }

    /// <summary>Gets the processed status of an import.</summary>
    /// <param name="productCode"></param>
    /// <param name="id">The id of the import job</param>
    /// <param name="libraryCode"></param>
    public Task<ProductUploadStatusDataModel> GetImportStatusAsync(string libraryCode, string productCode, int id)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/imports/{id}";
        return this.Get<ProductUploadStatusDataModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Gets the styles used during import of documents.</summary>
    public Task<ImportedDocumentStylesDataModel> GetImportStylesAsync()
    {
        var url = "content/import/styles";
        return this.Get<ImportedDocumentStylesDataModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Updates the styles used during import of documents.</summary>
    /// <returns>The styles were successfully updated</returns>
    public async Task PutImportStylesAsync(ImportStylesForm body)
    {
        var url = "content/import/styles";
        await this.Put(url, body, HttpStatusCode.OK);
    }

    /// <summary>Authenticate by username and password</summary>
    /// <param name="username">The username to authenticate as</param>
    /// <param name="password">The password of the user to authenticate as</param>
    /// <returns>The authentication key to use in future API requests.</returns>
    public async Task<string> GetAuthenticationTokenAsync(string username, string password)
    {
        var query = await CreateQueryString(new { username, password });
        var url = $"authenticate?{query}";
        return await this.Get<string>(url, HttpStatusCode.OK);
    }

    /// <summary>Search for products</summary>
    /// <param name="terms">The terms/words to search for within product content and metadata. Can contain logical operators e.g. AND, OR</param>
    /// <param name="categories">Deprecated, use CategoryPaths. When provided, filters the returned products to only include the products in the categories by category ID. When two categories are under the same top-level category, products in either category are returned ("OR"). When two categories are in different top-level categories, only products which are in both categories are returned ("AND")</param>
    /// <param name="categoryPaths">When provided, filters the returned products to only include the products in the categories by category path. When two categories are under the same top-level category, products in either category are returned ("OR"). When two categories are in different top-level categories, only products which are in both categories are returned ("AND")</param>
    /// <param name="orderBy">Specifies the order in which the products should be returned, as a comma-seperated string of fields. The field can be 'Title', 'Published', 'PublishedYear' and 'CanView' (license status), optionally followed by '.asc' (default), '.desc'</param>
    /// <param name="skip">The zero-based index of the product to start at. Used for paging</param>
    /// <param name="take">The number of product to retrieve this request. Used for paging. If the value is null (default), then the site's default pager number is used</param>
    /// <param name="includeUnlicensed">Whether to include products which are not licensed to the current user</param>
    /// <param name="includePrivate">Whether to include private products in the results, which the current user has a license to</param>
    /// <param name="includeComingSoon">Whether to include coming soon products in the results</param>
    /// <param name="includeArchived">Whether to include archived products in the results</param>
    /// <param name="includeDisabled">Whether to include disabled products in the results. This only works if the current user is a product administrator, and no terms are supplied</param>
    /// <param name="updatedSince">When set, results include reports that have been updated after the date given, UTC time zone.
    /// Note that UpdatedSince will not return reports that have only had the following edited since the date given:
    /// + uploading a content source document.
    /// + re-importing or importing an ids file.
    /// + marking a document as print copy or renaming an attachment.</param>
    /// <param name="maxAge">When set, results only include reports which are not older than the timespan indicated.
    /// Report age is determined from the published date.
    /// 
    /// Timespan must be a number between 0 and 99 followed by d, m or y.
    /// 
    /// E.g. "6m" for six months or "2y" for two years</param>
    /// <returns>A list of products</returns>
    public async Task<ProductSearchResults> GetProductsAsync(
        string terms,
        System.Collections.Generic.IEnumerable<int> categories,
        System.Collections.Generic.IEnumerable<string> categoryPaths,
        string orderBy,
        int? skip,
        int? take,
        bool? includeUnlicensed,
        bool? includePrivate,
        bool? includeComingSoon,
        bool? includeArchived,
        bool? includeDisabled,
        System.DateTime? updatedSince,
        string maxAge)
    {
        var query = await CreateQueryString(
            new
                {
                    terms,
                    categories,
                    categoryPaths,
                    orderBy,
                    skip,
                    take,
                    includeUnlicensed,
                    includePrivate,
                    includeComingSoon,
                    includeArchived,
                    includeDisabled,
                    updatedSince,
                    maxAge
                });
        var url = $"products?{query}";
        return await this.Get<ProductSearchResults>(url, HttpStatusCode.OK);
    }

    /// <summary>Get all current product links</summary>
    /// <returns>Successful operation</returns>
    public Task<List<ProductLinkModel>> GetAllProductLinksAsync()
    {
        var url = "products/links";
        return this.Get<List<ProductLinkModel>>(url, HttpStatusCode.OK);
    }

    /// <summary>Create a product link</summary>
    /// <param name="body">The details of the link</param>
    /// <returns>Successful operation</returns>
    public Task<ProductLinkDetailsModel> PostProductLinkAsync(ProductLinkDetailsForm body)
    {
        var url = "products/links";
        return this.Post<ProductLinkDetailsModel>(url, body, HttpStatusCode.OK);
    }

    /// <summary>Get the type of link and the products linked</summary>
    /// <param name="id">The id of the link</param>
    /// <returns>Successful operation</returns>
    public Task<ProductLinkDetailsModel> GetProductLinkAsync(int id)
    {
        var url = $"products/links/{id}";
        return this.Get<ProductLinkDetailsModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Edit an existing product link</summary>
    /// <param name="id">The id of the link</param>
    /// <param name="body">The details of the link</param>
    /// <returns>Successful operation</returns>
    public Task<ProductLinkDetailsModel> PutProductLinkAsync(int id, ProductLinkDetailsForm body)
    {
        var url = $"products/links/{id}";
        return this.Put<ProductLinkDetailsModel>(url, body, HttpStatusCode.OK);
    }

    /// <summary>Delete a product link</summary>
    /// <param name="id">The id of the link</param>
    /// <returns>Successful operation</returns>
    public Task DeleteProductLinkAsync(int id)
    {
        var url = $"products/links/{id}";
        return this.Delete(url, HttpStatusCode.NoContent);
    }

    /// <summary>Find product by code</summary>
    /// <param name="libraryCode">The library code for the product to return</param>
    /// <param name="productCode">The product code for the product to return</param>
    /// <param name="includeExtendedMetadata">Whether to include extended metadata, categories, authors, product links and buy it now link in the result</param>
    /// <param name="includeToc">Whether to include the table of contents of the product (will display appropriately for the current user)</param>
    /// <returns>Successful operation.</returns>
    public async Task<ProductMetadataModel> GetProductByCodeAsync(
        string libraryCode,
        string productCode,
        bool? includeExtendedMetadata,
        bool? includeToc)
    {
        var query = await CreateQueryString(new { includeExtendedMetadata, includeToc });
        var url = $"libraries/{libraryCode}/products/{productCode}?{query}";
        return await this.Get<ProductMetadataModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Add or update a product</summary>
    /// <param name="libraryCode">The library code for the product to update</param>
    /// <param name="productCode">The product code for the product to update</param>
    /// <param name="body">Metadata to update the product with</param>
    /// <returns>Product successfully created.</returns>
    public Task<ProductMetadataModel> PutProductAsync(
        string libraryCode,
        string productCode,
        ProductMetadataForm body)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}";
        return this.Put<ProductMetadataModel>(url, body, HttpStatusCode.Created);
    }

    /// <summary>Delete a product, if it exists</summary>
    /// <param name="libraryCode">The library code for the product to delete</param>
    /// <param name="productCode">The product code for the product to delete</param>
    /// <returns>Successful operation.</returns>
    public Task DeleteProductAsync(string libraryCode, string productCode)
    {
        var url = $"/libraries/{libraryCode}/products/{productCode}";
        return this.Delete(url, HttpStatusCode.NoContent);
    }

    /// <summary>Get a generated print copy of specified format</summary>
    /// <param name="libraryCode">The library code for the product to return</param>
    /// <param name="productCode">The product code for the product to return</param>
    /// <param name="extension">A file extension to look for (by default doc, pdf, xls and ppt are supported)</param>
    /// <param name="fileCode">The code of the file desired</param>
    /// <returns>Successful operation.</returns>
    public async Task<FileDownloadModel> GetPrintCopyAsync(
        string libraryCode,
        string productCode,
        string extension,
        string fileCode)
    {
        var query = await CreateQueryString(new { fileCode });
        var url = $"libraries/{libraryCode}/products/{productCode}/printcopies/{extension}?{query}";
        return await this.Get<FileDownloadModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Get an attachment file</summary>
    /// <param name="libraryCode">The library code for the product to return</param>
    /// <param name="productCode">The product code for the product to return</param>
    /// <param name="fileCode">The code of the file desired</param>
    /// <returns>Successful operation.</returns>
    public Task<FileDownloadModel> GetAttachmentAsync(string libraryCode, string productCode, string fileCode)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/attachments/{fileCode}";
        return this.Get<FileDownloadModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Get a main deliverable file from a product</summary>
    /// <param name="libraryCode">The library code for the product to return</param>
    /// <param name="productCode">The product code for the product to return</param>
    /// <returns>Successful operation.</returns>
    public Task<ProductContentModel> GetContentAsync(string libraryCode, string productCode)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/content";
        return this.Get<ProductContentModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Get the extended metadata for a product</summary>
    /// <param name="libraryCode">The library code for the product to return</param>
    /// <param name="productCode">The product code for the product to return</param>
    /// <returns>Successful operation.</returns>
    public Task<ProductExtendedMetadataModel> GetExtendedMetadataAsync(string libraryCode, string productCode)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/metadata";
        return this.Get<ProductExtendedMetadataModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Update the extended metadata for a product</summary>
    /// <param name="libraryCode">The library code for the product to update</param>
    /// <param name="productCode">The product code for the product to update</param>
    /// <param name="body">Metadata to update the product with</param>
    /// <returns>Successful operation.</returns>
    public Task PutExtendedMetadataAsync(string libraryCode, string productCode, ProductExtendedMetadataForm body)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/metadata";
        return this.Put(url, body, HttpStatusCode.NoContent);
    }

    /// <summary>Update the extended metadata for a product</summary>
    /// <param name="libraryCode">The library code for the product to update</param>
    /// <param name="productCode">The product code for the product to update</param>
    /// <param name="body">Commands to update the extended metadata</param>
    /// <returns>Successful operation.</returns>
    public Task PatchExtendedMetadataAsync(
        string libraryCode,
        string productCode,
        List<ProductExtendedMetadataCommand> body)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/metadata";
        return this.Patch(url, body, HttpStatusCode.NoContent);
    }

    /// <summary>Get the source files of the product.</summary>
    /// <param name="libraryCode">The library code for the product</param>
    /// <param name="productCode">The product code for the product to return</param>
    /// <param name="includeCategoryMetadata">Whether to include categories in the metadata</param>
    /// <returns>Successful operation.</returns>
    public async Task<string> GetSourceFilesAsync(string libraryCode, string productCode, bool? includeCategoryMetadata)
    {
        var query = await CreateQueryString(new { includeCategoryMetadata });
        var url = $"libraries/{libraryCode}/products/{libraryCode}/source?";
        return await this.Get<string>(url, HttpStatusCode.OK);
    }

    /// <summary>Get the categories a product is in</summary>
    /// <param name="libraryCode">The library code for the product to return</param>
    /// <param name="productCode">The product code for the product to return</param>
    /// <param name="includeHidden">Whether to include hidden categories or not. Only available for users in role "ReportAdmin".</param>
    /// <returns>Successful operation.</returns>
    public async Task<List<string>> GetProductCategoriesAsync(string libraryCode, string productCode, bool? includeHidden)
    {
        var query = await CreateQueryString(new { includeHidden });
        var url = $"libraries/{libraryCode}/products/{productCode}/categories?{query}";
        return await this.Get<List<string>>(url, HttpStatusCode.OK);
    }

    /// <summary>Update the categories a product is in</summary>
    /// <param name="libraryCode">The library code for the product to update</param>
    /// <param name="productCode">The product code for the product to update</param>
    /// <param name="body">The new categories the product should be in</param>
    /// <returns>Successful operation.</returns>
    public Task PutProductCategoriesAsync(string libraryCode, string productCode, List<string> body)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/categories";
        return this.Put(url, body, HttpStatusCode.OK);
    }

    /// <summary>Gets the top level categories, optionally including children</summary>
    /// <param name="includeHidden">Whether to include hidden categories or not. Only available for users in role "ReportAdmin".</param>
    /// <param name="includeDescendants">Whether to include descendants of the categories.
    /// 
    /// Warning: this can be a large amount of data and therefore slow. It is recommended to look up a specific category by id</param>
    /// <returns>Successful operation.</returns>
    public async Task<List<CategoryModel>> GetCategoriesAsync(bool? includeHidden, bool? includeDescendants)
    {
        var query = await CreateQueryString(new { includeHidden, includeDescendants });
        var url = $"categories?{query}";
        return await this.Get<List<CategoryModel>>(url, HttpStatusCode.OK);
    }

    /// <summary>Adds a category</summary>
    /// <param name="body">The details of the category to add</param>
    public Task<CreatedCategoryModel> PostCategoryAsync(CategoryDataForm body)
    {
        var url = "categories";
        return this.Post<CreatedCategoryModel>(url, body, HttpStatusCode.OK);
    }

    /// <summary>Get a specific category</summary>
    /// <param name="id">The id of the category to retrieve</param>
    /// <param name="includeHidden">Whether to include hidden categories or not. Only available for users in role "ReportAdmin".</param>
    /// <param name="includeDescendants">Whether to include descendants of the category.</param>
    /// <returns>Successful operation.</returns>
    public async Task<CategoryModel> GetCategoryAsync(string id, bool? includeHidden, bool? includeDescendants)
    {
        var query = await CreateQueryString(new { includeHidden, includeDescendants });
        var url = $"categories/{id}?";
        return await this.Get<CategoryModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Updates a category</summary>
    /// <param name="id">The id of the category to update</param>
    /// <param name="body">The details to update the category with</param>
    /// <returns>Successful operation</returns>
    public Task PutCategoryAsync(string id, CategoryDataForm body)
    {
        var url = $"categories/{id}";
        return this.Put(url, body, HttpStatusCode.OK);
    }

    /// <summary>Deletes a category</summary>
    /// <param name="id">The id of the category to delete</param>
    /// <returns>Successful operation</returns>
    public Task DeleteCategoryAsync(string id)
    {
        var url = $"categories/{id}";
        return this.Delete(url, HttpStatusCode.NoContent);
    }

    /// <summary>Get the products in a specific category</summary>
    /// <param name="id">The id of the category</param>
    /// <param name="includeDescendants">If true then all products which are in decendant categories will be added to the list created</param>
    /// <returns>Successful operation.</returns>
    public async Task<List<ProductRevisionIdModel>> GetProductsInCategoryAsync(string id, bool? includeDescendants)
    {
        var query = await CreateQueryString(new { includeDescendants });
        var url = $"categories/{id}/products?{query}";
        return await this.Get<List<ProductRevisionIdModel>>(url, HttpStatusCode.OK);
    }

    /// <summary>Get the authors of a product</summary>
    /// <param name="libraryCode">The library code for the product to return</param>
    /// <param name="productCode">The product code for the product to return</param>
    /// <returns>Successful operation.</returns>
    public Task<List<ProductAuthorForm>> GetAllProductAuthorsAsync(string libraryCode, string productCode)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/authors";
        return this.Get<List<ProductAuthorForm>>(url, HttpStatusCode.OK);
    }

    /// <summary>Update the authors of a product</summary>
    /// <param name="libraryCode">The library code for the product to update</param>
    /// <param name="productCode">The product code for the product to update</param>
    /// <param name="body"></param>
    /// <returns>Successful operation.</returns>
    public Task PutProductAuthorsAsync(string libraryCode, string productCode, List<ProductAuthorForm> body)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/authors";
        return this.Put(url, body, HttpStatusCode.NoContent);
    }

    /// <summary>Gets the table of contents for a product</summary>
    /// <param name="libraryCode">The library code for the product to return</param>
    /// <param name="productCode">The product code for the product to return</param>
    /// <returns>Successful operation.</returns>
    public Task<ProductTocModel> GetProductTocAsync(string libraryCode, string productCode)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/toc";
        return this.Get<ProductTocModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Gets an index of all text contained within the product</summary>
    /// <param name="libraryCode">The library code for the product to return</param>
    /// <param name="productCode">The product code for the product to return</param>
    /// <returns>Successful operation.</returns>
    public Task<string> GetProductTextIndexAsync(string libraryCode, string productCode)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/indexablecontent";
        return this.Get<string>(url, HttpStatusCode.OK);
    }

    /// <summary>Search for news items in a product</summary>
    /// <param name="libraryCode">The library code for the product containing the news items</param>
    /// <param name="productCode">The product code for the product containing the news items</param>
    /// <param name="publishedAfter">When provided, filters the returned items to only those published after the given date.</param>
    /// <param name="publishedBefore">When provided, filters the returned items to only those published before the given date.</param>
    /// <param name="skip">The zero-based index of the news item to start at. Used for paging</param>
    /// <param name="take">The number of news items to retrieve this request. Used for paging</param>
    /// <param name="sortDirection">The direction to sort news items by published date, and then id.</param>
    /// <param name="category">When provided, filters the returned items to only those which are in the specified news category.</param>
    /// <param name="q">When provided, filters the returned items to only those which match the search term.</param>
    /// <returns>Successful operation.</returns>
    public async Task<NewsItemSearchResult> GetProductNewsItemsAsync(
        string libraryCode,
        string productCode,
        DateTime? publishedAfter,
        DateTime? publishedBefore,
        int? skip,
        int? take,
        SortDirection? sortDirection,
        string category,
        string q)
    {
        var query = await CreateQueryString(
            new
                {
                    publishedAfter,
                    publishedBefore,
                    skip,
                    take,
                    sortDirection,
                    category,
                    q
                });
        var url = $"libraries/{libraryCode}/products/{productCode}/news-items?{query}";
        return await this.Get<NewsItemSearchResult>(url, HttpStatusCode.OK);
    }

    /// <summary>Gets a specific news item</summary>
    /// <param name="libraryCode">The library code for the product containing the news item</param>
    /// <param name="productCode">The product code for the product containing the news item</param>
    /// <param name="id">The id of the news item to retrieve</param>
    /// <returns>Successful operation.</returns>
    public Task<NewsItemDataModel> GetNewsItemAsync(string libraryCode, string productCode, string id)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/news-items/{id}";
        return this.Get<NewsItemDataModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Gets the file types the current subscriber can export</summary>
    /// <returns>Successful operation</returns>
    public Task<List<string>> GetCurrentSubscriberExportPermissionsAsync()
    {
        var url = "subscriber/exportable-file-extensions";
        return this.Get<List<string>>(url, HttpStatusCode.OK);
    }

    /// <summary>Get all the accounts available to the current user.</summary>
    /// <returns>Successful operation.</returns>
    public Task<List<AccountSearchResults>> GetAllAvailableAccountsAsync()
    {
        var url = "accounts";
        return this.Get<List<AccountSearchResults>>(url, HttpStatusCode.OK);
    }

    /// <summary>Resets the password of each enabled, non shared user in the account and then sends a welcome email to each of them</summary>
    /// <param name="body">Account names.</param>
    /// <returns>The emails were successfully sent</returns>
    public Task ResetPasswordsAndSendWelcomeEmailAsync(WelcomeEmailForm body)
    {
        var url = "accounts/registration/send-welcome-email";
        return this.Post(url, body, HttpStatusCode.OK);
    }

    /// <summary>Get an account with a specific name</summary>
    /// <param name="accountName">The name of the account to be retrieved.</param>
    /// <returns>Successful operation.</returns>
    public Task<AccountSearchResults> GetAccountAsync(string accountName)
    {
        var url = $"accounts/{accountName}";
        return this.Get<AccountSearchResults>(url, HttpStatusCode.OK);
    }

    /// <summary>Create or edit an account</summary>
    /// <param name="accountName">The name of the account to be edited. If the account name is not in use, the account will be created.</param>
    /// <param name="body">Account information.</param>
    /// <returns>The account was successfully edited.</returns>
    public Task PutAccountAsync(string accountName, AccountCreateForm body)
    {
        var url = $"accounts/{accountName}";
        return this.Put(url, body, HttpStatusCode.OK, HttpStatusCode.Created);
    }

    /// <summary>Delete an account, if it exists</summary>
    /// <param name="accountName">The name of the account to be deleted.</param>
    /// <returns>Successful operation.</returns>
    public Task DeleteAccountAsync(string accountName)
    {
        var url = $"accounts/{accountName}";
        return this.Delete(url, HttpStatusCode.NoContent);
    }

    /// <summary>Get registration options for an account.</summary>
    /// <param name="accountName">The name of the account desired.</param>
    /// <returns>Successful operation.</returns>
    public Task<AccountAccessSearchResults> GetRegistrationOptionsAsync(string accountName)
    {
        var url = $"accounts/{accountName}/registration";
        return this.Get<AccountAccessSearchResults>(url, HttpStatusCode.OK);
    }

    /// <summary>Set registration options for an account.</summary>
    /// <param name="accountName">The name of the account currently.</param>
    /// <param name="body">Possible values are NoRegistration, AccessCodeOnly, AllowAnyone and GuestUserButNoRegistration.</param>
    /// <returns>The account registration information was successfully edited.</returns>
    public Task PutRegistrationOptionsAsync(string accountName, AccountRegistrationCreateForm body)
    {
        var url = $"accounts/{accountName}/registration";
        return this.Put(url, body, HttpStatusCode.OK);
    }

    /// <summary>Gets the subscriber with the specified username</summary>
    /// <param name="username">The username of the subscriber to retrieve</param>
    /// <returns>Successful operation</returns>
    public Task<SubscriberDataModel> GetSubscriberAsync(string username)
    {
        var url = $"subscribers/{username}";
        return this.Get<SubscriberDataModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Gets all the subscribers in the account with the specified name</summary>
    /// <param name="accountName">The name of the account to retrieve the subscribers from</param>
    /// <returns>Successful operation</returns>
    public Task<SubscriberDataModel> GetSubscribersAsync(string accountName)
    {
        var url = $"accounts/{accountName}/subscribers";
        return this.Get<SubscriberDataModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Creates or updates the subscriber with the specified username</summary>
    /// <param name="accountName">The name of the account the subscriber to edit or create is in</param>
    /// <param name="username">The username of the subscriber to edit or create</param>
    /// <param name="body">Information to update the existing subscriber with or add to a new subscriber (a valid and unique email must be provided)</param>
    /// <returns>Subscriber was edited successfully</returns>
    public Task PutSubscriberAsync(string accountName, string username, SubscriberDataForm body)
    {
        var url = $"accounts/{accountName}/subscribers/{username}";
        return this.Put(url, body, HttpStatusCode.OK, HttpStatusCode.Created);
    }

    /// <summary>Deletes the subscriber with the specified username</summary>
    /// <param name="accountName">The name of the account the subscriber to delete is in</param>
    /// <param name="username">The username of the subscriber to delete</param>
    /// <returns>Subscriber was deleted successfully</returns>
    public Task DeleteSubscriberAsync(string accountName, string username)
    {
        var url = $"accounts/{accountName}/subscribers/{username}";
        return this.Delete(url, HttpStatusCode.NoContent);
    }

    /// <summary>Adds a report license to all users on an account</summary>
    /// <param name="accountName">The name of the account to add the license to</param>
    /// <param name="body">Information of the license to add</param>
    /// <returns>License was added successfully</returns>
    public Task PostReportLicenseAsync(string accountName, CreateUserLicenseForm body)
    {
        var url = $"accounts/{accountName}/ReportLicenses";
        return this.Post(url, body, HttpStatusCode.Created);
    }

    /// <summary>Returns a list of all report licenses available on an account</summary>
    /// <param name="accountName">The name of the account to get the licenses of</param>
    /// <param name="skip">Skip the first X licenses. Used for paging</param>
    /// <param name="take">The number of licenses to retrieve from this request. Used for paging. If the value is null (default), then up to 1000 licenses will be retrieved</param>
    /// <returns>Success</returns>
    public async Task<LicenseQueryResultModel<ReportLicenseModel>> GetReportLicensesAsync(
        string accountName,
        int? skip,
        int? take)
    {
        var query = await CreateQueryString(new { skip, take });
        var url = $"accounts/{accountName}/ReportLicenses?{query}";
        return await this.Get<LicenseQueryResultModel<ReportLicenseModel>>(url, HttpStatusCode.OK);
    }

    /// <summary>Removes a report license from all users on an account</summary>
    /// <param name="accountName">The name of the account to delete the license from</param>
    /// <param name="licenseId">Id of license to delete</param>
    /// <returns>License was successfully deleted</returns>
    public Task DeleteReportLicenseAsync(string accountName, int licenseId)
    {
        var url = $"accounts/{accountName}/ReportLicenses/{licenseId}";
        return this.Delete(url, HttpStatusCode.NoContent);
    }

    /// <summary>Adds a category license to all users on an account</summary>
    /// <param name="accountName">The name of the account to add the license to</param>
    /// <param name="body">Information of the license to add</param>
    /// <returns>License was added successfully</returns>
    public Task PostCategoryLicenseAsync(string accountName, CreateCategoryLicenseForm body)
    {
        var url = $"accounts/{accountName}/category-licenses";
        return this.Post(url, body, HttpStatusCode.Created);
    }

    /// <summary>Returns a list of all category licenses available on an account</summary>
    /// <param name="accountName">The name of the account to get the licenses of</param>
    /// <param name="skip">Skip the first X licenses. Used for paging</param>
    /// <param name="take">The number of licenses to retrieve from this request. Used for paging. If the value is null (default), then up to 1000 licenses will be retrieved</param>
    /// <returns>Success</returns>
    public async Task<LicenseQueryResultModel<CategoryLicenseModel>> GetAllCategoriesForAccountAsync(
        string accountName,
        int? skip,
        int? take)
    {
        var query = await CreateQueryString(new { skip, take });
        var url = $"accounts/{accountName}/category-licenses?";
        return await this.Get<LicenseQueryResultModel<CategoryLicenseModel>>(url, HttpStatusCode.OK);
    }

    /// <summary>Removes a category license from all users on an account</summary>
    /// <param name="accountName">The name of the account to delete the license from</param>
    /// <param name="licenseId">Id of license to delete</param>
    /// <returns>License was successfully deleted</returns>
    public Task DeleteCategoryLicenseAsync(string accountName, int licenseId)
    {
        var url = $"accounts/{accountName}/category-licenses/{licenseId}";
        return this.Delete(url, HttpStatusCode.NoContent);
    }

    /// <summary>Adds a report license to a specific user</summary>
    /// <param name="username">The name of the user to add the license to</param>
    /// <param name="body">Information of the license to add</param>
    /// <returns>License was added successfully</returns>
    public Task PostReportLicenseForUserAsync(string username, CreateUserLicenseForm body)
    {
        var url = $"subscribers/{username}/ReportLicenses";
        return this.Post(url, body, HttpStatusCode.Created);
    }

    /// <summary>Returns a list of all report licenses available to a specific user</summary>
    /// <param name="username">The username of the user to get the licenses of</param>
    /// <param name="skip">Skip the first X licenses. Used for paging</param>
    /// <param name="take">The number of licenses to retrieve from this request. Used for paging. If the value is null (default), then up to 1000 licenses will be retrieved</param>
    /// <returns>Success</returns>
    public async Task<LicenseQueryResultModel<ReportLicenseModel>> GetReportLicensesForUserAsync(
        string username,
        int? skip,
        int? take)
    {
        var query = await CreateQueryString(new { skip, take });
        var url = $"subscribers/{username}/ReportLicenses?{query}";
        return await this.Get<LicenseQueryResultModel<ReportLicenseModel>>(url, HttpStatusCode.OK);
    }

    /// <summary>Get the searches saved by a subscriber</summary>
    /// <param name="username">The username of the subscriber</param>
    public Task<List<SavedSearchListModel>> GetSavedSearchesAsync(string username)
    {
        var url = $"subscribers/{username}/saved-searches";
        return this.Get<List<SavedSearchListModel>>(url, HttpStatusCode.OK);
    }

    /// <summary>Save a new search on behalf of a subscriber</summary>
    /// <param name="username">The username of the subscriber</param>
    /// <param name="body"></param>
    /// <returns>Saved search was added successfully. Will return default values for parameters that are not set if applicable.</returns>
    public Task<SavedSearchModel> PostSavedSearchAsync(string username, AddSavedSearchForm body)
    {
        var url = $"subscribers/{username}/saved-searches";
        return this.Post<SavedSearchModel>(url, body, HttpStatusCode.Created);
    }

    /// <summary>Get the details of a specific saved search for a user</summary>
    /// <param name="username">The username of the subscriber</param>
    /// <param name="id">The id of the search to get. This can be gotten from the "/subscribers/{username}/SavedSearches" method</param>
    /// <returns>Successful operation</returns>
    public Task<SavedSearchModel> GetSavedSearchAsync(string username, int id)
    {
        var url = $"subscribers/{username}/saved-searches/{id}";
        return this.Get<SavedSearchModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Delete a saved search for a user</summary>
    /// <param name="username">The username of the subscriber</param>
    /// <param name="id">The id of the search to get. This can be gotten from the /subscribers/{username}/saved-searches method</param>
    /// <returns>Successfully deleted saved search</returns>
    public Task DeleteSavedSearchAsync(string username, int id)
    {
        var url = $"subscribers/{username}/saved-searches/{id}";
        return this.Delete(url, HttpStatusCode.NoContent);
    }

    /// <summary>Removes a report license from a specific user</summary>
    /// <param name="username">The username of the user to delete the license from</param>
    /// <param name="id">Id of license to delete</param>
    /// <returns>License was successfully deleted</returns>
    public Task DeleteReportLicenseForUserAsync(string username, int id)
    {
        var url = $"subscribers/{username}/ReportLicenses/{id}";
        return this.Delete(url, HttpStatusCode.NoContent);
    }

    /// <summary>Adds a category license to a specific user</summary>
    /// <param name="username">The username of the user to add the license to</param>
    /// <param name="body">Information of the license to add</param>
    /// <returns>License was added successfully</returns>
    public Task PostCategoryLicenseForUser(string username, CreateCategoryLicenseForm body)
    {
        var url = $"subscribers/{username}/category-licenses";
        return this.Post(url, HttpStatusCode.Created);
    }

    /// <summary>Returns a list of all category licenses available to a specific user</summary>
    /// <param name="username">The username of the user to get the licenses of</param>
    /// <param name="skip">Skip the first X licenses. Used for paging</param>
    /// <param name="take">The number of licenses to retrieve from this request. Used for paging. If the value is null (default), then up to 1000 licenses will be retrieved</param>
    /// <returns>Success</returns>
    public async Task<LicenseQueryResultModel<CategoryLicenseModel>> GetCategoryLicensesForUser(
        string username,
        int? skip,
        int? take)
    {
        var query = await CreateQueryString(new { skip, take });
        var url = $"subscribers/{username}/category-licenses?{query}";
        return await this.Get<LicenseQueryResultModel<CategoryLicenseModel>>(url, HttpStatusCode.OK);
    }

    /// <summary>Removes a category license from a specific user</summary>
    /// <param name="username">The username of the user to delete the license from</param>
    /// <param name="licenseId">Id of license to delete</param>
    /// <returns>License was successfully deleted</returns>
    public Task DeleteCategoryLicenseForUser(string username, int licenseId)
    {
        var url = $"subscribers/{username}/category-licenses/{licenseId}";
        return this.Delete(url, HttpStatusCode.NoContent);
    }

    /// <summary>Gets a license</summary>
    /// <param name="licenseId">Id of license to retrieve</param>
    /// <returns>Successful operation</returns>
    public Task<LicenseModel> GetLicenseAsync(int licenseId)
    {
        var url = $"licenses/{licenseId}";
        return this.Get<LicenseModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Edit external report link settings</summary>
    /// <param name="libraryCode">The library code of the external report to edit</param>
    /// <param name="productCode">The product code of the external report to edit</param>
    /// <param name="body">The information to edit the external report link settings with</param>
    /// <returns>Edited successfully</returns>
    public Task PutExternalReportLinkSettingsAsync(string libraryCode, string productCode, ExternalProductLinkForm body)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/ExternalProductLink";
        return this.Put(url, body, HttpStatusCode.OK);
    }

    /// <summary>Get external report link settings</summary>
    /// <param name="libraryCode">The library code of the external report to get</param>
    /// <param name="productCode">The product code of the external report to get</param>
    /// <returns>Success</returns>
    public Task<ExternalProductLinkForm> GetExternalReportLinkSettingsAsync(string libraryCode, string productCode)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/ExternalProductLink";
        return this.Get<ExternalProductLinkForm>(url, HttpStatusCode.OK);
    }

    /// <summary>Uploads a marketing brochure to a product</summary>
    /// <param name="body">The contents and extension of the file to upload</param>
    /// <param name="libraryCode">The library code of the product to upload the brochure to</param>
    /// <param name="productCode">The product code of the product to upload the brochure to</param>
    /// <returns>Success</returns>
    public Task PostMarketingBrochureAsync(string libraryCode, string productCode, MarketingBrochureForm body)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/marketing-brochure-file";
        return this.Post(url, body, HttpStatusCode.OK);
    }

    /// <summary>Gets a temporary URL for the marketing brochure of a product</summary>
    /// <param name="libraryCode">The library code of the product to retrieve the marketing brochure for</param>
    /// <param name="productCode">The product code of the product to retrieve the marketing brochure for</param>
    /// <returns>Success</returns>
    public Task<MarketingBrochureModel> GetMarketingBrochureUrlAsync(string libraryCode, string productCode)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/marketing-brochure-file";
        return this.Get<MarketingBrochureModel>(url, HttpStatusCode.OK);
    }

    /// <summary>Deletes the uploaded marketing brochure for a product</summary>
    /// <param name="libraryCode">The library code of the product to delete the marketing brochure from</param>
    /// <param name="productCode">The product code of the product to delete the marketing brochure from</param>
    /// <returns>Success</returns>
    public Task DeleteMarketingBrochureAsync(string libraryCode, string productCode)
    {
        var url = $"libraries/{libraryCode}/products/{productCode}/marketing-brochure-file";
        return this.Delete(url, HttpStatusCode.NoContent);
    }

    private async Task<T> Get<T>(string url, params HttpStatusCode[] responseCode)
    {
        using (var response = await this.httpClient.GetAsync(url))
        {
            if (responseCode.Any(c => response.StatusCode == c))
            {
                return JsonConvert.DeserializeObject<T>(await GetJson(response));
            }

            throw new InvalidOperationException(
                $"{response.StatusCode} returned from GET \"{url}\", because {await GetJson(response)}");
        }
    }

    private async Task Post(string url, object body, params HttpStatusCode[] responseCode)
    {
        var content = new StringContent(JsonConvert.SerializeObject(body));
        content.Headers.ContentType.MediaType = "application/json";
        using (var response = await this.httpClient.PostAsync(url, content))
        {
            if (responseCode.Any(c => response.StatusCode == c))
            {
                return;
            }

            throw new InvalidOperationException(
                $"{response.StatusCode} returned from POST \"{url}\", because {await GetJson(response)}");
        }
    }

    private async Task<T> Post<T>(string url, object body, params HttpStatusCode[] responseCode)
    {
        var content = new StringContent(JsonConvert.SerializeObject(body));
        content.Headers.ContentType.MediaType = "application/json";
        using (var response = await this.httpClient.PostAsync(url, content))
        {
            if (responseCode.Any(c => response.StatusCode == c))
            {
                return JsonConvert.DeserializeObject<T>(await GetJson(response));
            }

            throw new InvalidOperationException(
                $"{response.StatusCode} returned from POST \"{url}\", because {await GetJson(response)}");
        }
    }

    private async Task Put(string url, object body, params HttpStatusCode[] responseCode)
    {
        var content = new StringContent(JsonConvert.SerializeObject(body));
        content.Headers.ContentType.MediaType = "application/json";
        using (var response = await this.httpClient.PostAsync(url, content))
        {
            if (responseCode.Any(c => response.StatusCode == c))
            {
                return;
            }

            throw new InvalidOperationException(
                $"{response.StatusCode} returned from PUT \"{url}\", because {await GetJson(response)}");
        }
    }

    private async Task<T> Put<T>(string url, object body, params HttpStatusCode[] responseCode)
    {
        var content = new StringContent(JsonConvert.SerializeObject(body));
        content.Headers.ContentType.MediaType = "application/json";
        using (var response = await this.httpClient.PutAsync(url, content))
        {
            if (responseCode.Any(c => response.StatusCode == c))
            {
                return JsonConvert.DeserializeObject<T>(await GetJson(response));
            }

            throw new InvalidOperationException(
                $"{response.StatusCode} returned from PUT \"{url}\", because {await GetJson(response)}");
        }
    }

    private async Task Patch(string url, object body, params HttpStatusCode[] responseCode)
    {
        var content = new StringContent(JsonConvert.SerializeObject(body));
        content.Headers.ContentType.MediaType = "application/json";
        using (var response = await this.httpClient.PatchAsync(url, content))
        {
            if (responseCode.Any(c => response.StatusCode == c))
            {
                return;
            }

            throw new InvalidOperationException(
                $"{response.StatusCode} returned from PATCH \"{url}\", because {await GetJson(response)}");
        }
    }

    private async Task Delete(string url, params HttpStatusCode[] responseCode)
    {
        using (var response = await this.httpClient.DeleteAsync(url))
        {
            if (responseCode.Any(c => response.StatusCode == c))
            {
                return;
            }

            throw new InvalidOperationException(
                $"{response.StatusCode} returned from DELETE \"{url}\", because {await GetJson(response)}");
        }
    }

    private static Task<string> CreateQueryString(object parameters)
    {
        var dictionary = parameters.GetType()
                                   .GetProperties()
                                   .Select(i => Tuple.Create(i.Name, i.GetValue(parameters)))
                                   .Where(t => t.Item2 != null)
                                   .ToDictionary(t => t.Item1, t => t.Item2.ToString());

        using (var content = new FormUrlEncodedContent(dictionary))
        {
            return content.ReadAsStringAsync();
        }
    }

    private static async Task<string> GetJson(HttpResponseMessage response)
    {
        return await response.Content.ReadAsStringAsync();
    }

    private bool disposedValue = false;

    protected virtual void Dispose(bool disposing)
    {
        if (!disposedValue)
        {
            if (disposing)
            {
                this.httpClient?.Dispose();
            }

            disposedValue = true;
        }
    }

    void IDisposable.Dispose()
    {
        Dispose(true);
    }
}